---
format: 
   revealjs:
    embed-resources: true
    theme: serif
    slide-level: 3
    slide-number: true
    show-slide-number: all
    preview-links: auto
    number-sections: true
title: "Exercise 7.3 Network Randomization"
author: "Team 3"
---

```{r, include=FALSE}
# Load packages
library(igraph)
library(tidyverse)
library(tidygraph)
library(ggraph)
library(knitr)
library(kableExtra)

set.seed(1142)

```

## Creating a network of friends in a class and plotting it

```{r, echo = TRUE}

n <- 30
radius <- .2

netw <- sample_grg(n, radius, torus = T)
D <- distances(netw)
G <- tbl_graph(nodes = 1:n, edges = get.edgelist(netw)) |> 
  dplyr::mutate(group = "control")

.plot <- function(G){
  set.seed(1)
  G |> 
    ggraph(layout = "igraph", algorithm = "gem")  +
    geom_node_point(size = 10, aes(color = group)) +
    geom_node_text(size = 5, aes(label = nodes), color = "white") +
    geom_edge_diagonal() +
    scale_color_manual(breaks = c("control", "treated", "friend", "friend_of_friend"),
                       values = c("grey80", "darkred", "darkgreen", "lightgreen"))
}
```

## Distance matrix

```{r, echo = TRUE}
D |> kable() |>  kable_styling(font_size = 10)
```

## Creating a network of friends in a class and plotting it

```{r, echo = TRUE}
.plot(G)
```

## Treating a random person

```{r, echo = TRUE}
treat_1 <- (1:n) |> sample(1)
friends <- (1:n)[D[,treat_1]==1]
fof <-     (1:n)[D[,treat_1]==2]

G <- dplyr::mutate(G, group = case_when(
  nodes == treat_1   ~ "treated",
  nodes %in% friends ~ "friend",
  nodes %in% fof     ~ "friend_of_friend",
  T ~ group
))
```

## Treating a random person

```{r, echo = TRUE}
.plot(G)
```

## Treat a second random person 
```{r, echo = F}
treat_2 <- (1:n)[D[,treat_1]>=4] |> sample(1)
friends <- (1:n)[D[,treat_2]==1]
fof <-     (1:n)[D[,treat_2]==2]

G <- dplyr::mutate(G, group = case_when(
  nodes == treat_2   ~ "treated",
  nodes %in% friends ~ "friend",
  nodes %in% fof     ~ "friend_of_friend",
  T ~ group
))
.plot(G)
```

## Treat a third random person

```{r, echo=F}
treat_3 <- (1:n)[D[,treat_1]>=4 & D[,treat_2]>=4] |> sample(1)
friends <- (1:n)[D[,treat_3]==1]
fof <-     (1:n)[D[,treat_3]==2]

G <- dplyr::mutate(G, group = case_when(
  nodes == treat_3 ~ "treated",
  nodes %in% friends ~ "friend",
  nodes %in% fof & group != "friend" ~ "friend_of_friend",
  T ~ group
))
.plot(G)
```

## Treat fourth person: none left!

```{r, echo=TRUE}
(1:n)[D[,treat_1]>=4 & D[,treat_2]>=4 & D[,treat_3]>=4]
```

## Idea for calculating treatment assignment probabilities

Return to the distances matrix:

```{r, echo = F}
D |> kable() |>  kable_styling(font_size = 10)
```

## Idea for calculating treatment assignment probabilities

Return to the distances matrix

- Find all sets of nodes S = {s_i, s_2, ...}, where distance between all nodes in  all sets s_x is at least 4
- P(T_i) = sum_j(s_i in s_j) / size(S)